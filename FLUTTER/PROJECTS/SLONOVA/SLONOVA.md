# Slonova и трудности разработки

## Проблемы и улучшения в дальнейшей поддержке

### Отсутствие нативного плеера для взаимодействия с медиафайлами

На `Android` существует проблема с воспроизведением медиафайлов в фоновом режиме. Проблема связанна с тем, что
подсистема внутри `Android` отвечающая за оптимизацию фоновых процессов, убивает приложение, так как не видит причин,
для того, чтобы оставлять этот процесс в живых. На данный момент существует механизм, который поддерживает жизнь
приложения в виде `lib\task_handler.dart`.

Чтобы решить эту проблему корректно, необходимо создать модуль, который будет отвечать за воспроизведение медиафайлов в
виде нативного плеера в шторке уведомлений. Это должно решить проблему, так как система будет видеть, что приложение в
фоне воспроизводит медиафайлы и не будет его убивать.

### Лишние запросы при получении фаворитов и сохраненных записей

Сейчас существуют лишние запросы при открытии экрана детального плеера, или попытке взаимодействовать на списках с
детальной информацией. Это связанно с тем, что не было внятного и удобного решения для хранения данных через единый
источник. В результате, при каждом обращении к элементу, мы делаем запрос на сервер, чтобы получить статус фаворита и к
локальному хранилищу, чтобы получить статус сохраненной записи.

Для решения этой проблемы необходимо создать единый источник данных, который сможет следить за всеми зависимыми
компонентами. В такой ситуации мы можем воспользоваться двумя решениями: `Scope` и `BlocRepository`. В обоих случаях мы
используем единый источник данных, за счет использования единых экземпляров класса и в случае необходимости передавать
данные от одного к остальным.

### Service Locator и Dependency Injection Container

Сейчас в приложении вся инъекция зависимостей происходит через `Service Locator`, но чтобы улучшить понимание
зависимостей и работу с ними, можно порекомендовать использовать `Dependency Injection Container`. Для изменения,
необходимо будет создать класс, который будет отвечать за хранения зависимостей и внедрить его через `InheritedWidget`.
А в соответствующих местах полностью убрать вызов `injector<T>` в пользу `DependencyScope.of(context).`

### Неправильное взаимодействие с моделями и сущностями

Данная проблема существует на почти всех проектах и лучшее решение сейчас находиться в `Charity`. Рекомендую создать
родителя в виде сущности, которая унаследована от `equatable`. В свое время, от `dto` будет наследоваться от `entity`, и
расширять его своими методами для взаимодействия с данными, такими как преобразование `json` или работы с моделями базы
данных.

Таким образом, должно получиться, что из прослойки отвечающей за взаимодействия с источником правды(сеть, БД, т.д.) мы
должны возвращать и отдавать сущность. В то время как dto будет существовать только в этой закрытой зоне, чтобы связать
сырые данные с сущностью.

### Разные окружения на разных ветках

Аналогичная проблема, как на `PizzaWay`, где существует разные окружения на разных ветках. Как описано ранее, в
документе связанном с `PizzaWay`, необходимо создать разные окружения при помощи `flavor`. В таком случае, у нас будет
возможность подменивать окружения не создавая зависимость от ветки создания.

### Роутинг

Как и в большинстве проектов, навигация построена на `go_router`, что влечет за собой не только единый подход к
написанию кода, но и единые проблемы, которые были решены позже, а тут они остались. Для начала, несмотря на одну
библиотеку, тут используется код-генерация, что не подготовленного разработчика может запутать. Во-вторых, нужно
перестроить все деверья внутри путей, так как сейчас работаю не корректно. Простой способ верно выстроенного пути
простой. Если вы сделаете `context.go('route1/route2/route3')` и у вас выстроиться стек из 3 экранов, то все работает
верно, в ином случае где-то ошибка.

Так же, стоит передавать данные через путь, а не через аргументы, так как это упростит работу с навигацией и позволит в
дальнейшем использовать `deeplinks`, без страха о том, что что-то сломается.

### Унифицированные действия

В проекте действия, что отвечают за запуск медиа плеера, находятся в `lib\future_utils.dart`, и такое решение лучше
вынести в другое место и сменить его имя. В идеале эту логику вынести в какой-то другой виджет, чтобы он возвращал эту
функцию и был оберткой для другого. Таким образом, мы сможем унифицировать действия и не дублировать код, убрав его из
плохого решения.