# React-Native app security rules and recommendations
**Max Orlov 06.12.2023**

# 1. Signature and Timestamp in API Requests
"Signature" в API-запросах обычно представляет собой строку, полученную с использованием определенного алгоритма хеширования (например, HMAC) и секретного ключа для обеспечения целостности и аутентификации запроса. Это важная мера безопасности, используемая для защиты API от несанкционированного доступа и подделок.

Вместе с подписью обычно включается также "timestamp" (временная метка), которая представляет собой временной штамп в момент создания запроса. Это позволяет предотвращать атаки воспроизведения, поскольку запрос с предыдущим временным штампом будет считаться устаревшим и недействительным.

Вот как это может работать в простых шагах:

1. **Генерация "timestamp":**
   API-клиент генерирует временную метку, представляющую текущее время в момент создания запроса. Это может быть в формате UNIX-времени, ISO 8601 и т. д.

2. **Подготовка данных для подписи:**
   API-клиент собирает все данные запроса (включая параметры и тело запроса), а также "timestamp". Эти данные будут использоваться для создания подписи.

3. **Создание подписи:**
   С использованием секретного ключа и выбранного алгоритма хеширования (например, HMAC-SHA256), API-клиент создает подпись, хешируя подготовленные данные.

4. **Включение подписи и временной метки в запрос:**
   Полученная подпись и временная метка добавляются к заголовкам или параметрам запроса. Например:

```ts
    import { sha256 } from 'js-sha256';


    private getSignature = (data?: object) => {

        // Собираем сигнатуру из значений передаваемых данных в том числе и timestamp
        let result = '';
        if (typeof data === 'object' && data) {
            result = Object.values(data).join(':');
        };
        return result;
    };

    private getTimestamp = () => {
        const timestamp = moment().valueOf() + [SERVER_TIME_SHIFT get this variable from server before send requests, to sinchronization with server time];
        return timestamp;
    };

   const APIRequest = ()=>{
      // Generate signature
      const timestamp = this.getTimestamp();
      const message = this.getSignature({ ...data, timestamp });
      const hash = sha256.hmac.create( YOUR_SIGNATURE_KEY );
      hash.update(message);
      const signature = hash.hex();

      headers: {
         'Cache-Control': 'no-cache',
         'Content-Type': 'application/json',
         'authorization': YOUR_API_TOKEN
         'X-Timestamp': timestamp,
         'X-Signature': signature,
      },
      // your request...
    }
```

5. **Проверка подписи на стороне сервера:**
   При получении запроса сервер извлекает временную метку и подпись из запроса и повторяет процесс генерации подписи, используя свой секретный ключ. Если подписи совпадают и разница во времени между полученной временной меткой и текущим временем сервера не превышает допустимого интервала, запрос считается действительным.

Это обеспечивает безопасность передачи данных и гарантирует, что запросы к API происходят только от авторизованных клиентов, а также что они не были изменены в пути.


# 2. react-native-keychain - Безопасное хранение данных

`react-native-keychain` — это библиотека для React Native, предназначенная для безопасного хранения учетных данных, таких как логины и пароли, на мобильных устройствах. Эта библиотека обеспечивает интерфейс для работы с хранилищем безопасности операционной системы (Keychain в iOS и Keystore в Android), где данные могут храниться в зашифрованном виде.

Вот основные аспекты `react-native-keychain`:

1. **Хранение безопасных данных:**
   `react-native-keychain` предоставляет простые методы для сохранения и извлечения учетных данных (логинов, паролей и т. д.) в безопасном хранилище устройства.

2. **Использование операционных системных ключей:**
   Библиотека взаимодействует с ключами безопасности операционной системы, такими как Keychain в iOS и Keystore в Android, чтобы обеспечить максимальную безопасность данных.

3. **Поддержка Touch ID / Face ID (iOS) и BiometricPrompt (Android):**
   `react-native-keychain` предоставляет возможность использовать биометрическую аутентификацию для доступа к учетным данным, если устройство поддерживает эти функции.

4. **Простой API:**
   Библиотека предоставляет простой API, что делает ее удобной в использовании для разработчиков React Native. Например, для сохранения данных в хранилище, можно использовать следующий код:

   ```javascript
   import * as Keychain from 'react-native-keychain';

   // Сохранение учетных данных
   Keychain.setGenericPassword('username', 'password');

   // Извлечение учетных данных
   const credentials = await Keychain.getGenericPassword();
   console.log(credentials); // { username: 'username', password: 'password' }
   ```

5. **Кроссплатформенность:**
   `react-native-keychain` обеспечивает кроссплатформенный доступ к безопасному хранилищу, что позволяет использовать ее на устройствах под управлением iOS и Android.

Эта библиотека полезна для приложений, которые требуют сохранения чувствительных данных, и она помогает разработчикам обеспечивать высокий уровень безопасности в их React Native приложениях.

Читайте документацию:
https://github.com/oblador/react-native-keychain

# 3. ProGuard 
Это инструмент оптимизации и обфускации кода для приложений на Java и Android. Он удаляет неиспользуемые классы, методы, поля и аргументы, а также обфусцирует имена классов, методов и полей, чтобы сделать исходный код более сложным для восприятия и анализа.

В React Native, ProGuard используется в процессе сборки Android-приложения. Он применяется к байт-коду Java, который генерируется при сборке вашего React Native проекта.

### **Настройка файла `build.gradle`:**

В вашем файле `android/app/build.gradle` убедитесь, что ProGuard включен:

```gradle
android {
  ...
  buildTypes {
    release {
      ...
      minifyEnabled true
      proguardFiles getDefaultProguardFile("proguard-android.txt"), "proguard-rules.pro"
    }
  }
}
```

`getDefaultProguardFile("proguard-android-optimize.txt")` включает более строгие правила для оптимизации.

### Разница с конфигом `optimize`:

`optimize` - это параметр, который определяет, будет ли использоваться оптимизация кода в ProGuard. Когда используете `optimize`, ProGuard будет применять более агрессивные оптимизации для кода, что может уменьшить размер приложения и улучшить его производительность. Однако, в редких случаях, эти оптимизации могут вызывать проблемы с работой приложения.

При использовании оптимизированого конфига может возникнуть проблема с отображением картинок добавте слудующую строку в `android/app/proguard-rules.pro`:
```
-keep class com.artcryptowallet.BuildConfig { *; }
```

Если у вас возникают проблемы после включения оптимизации, верните proguard-android.txt

```gradle
android {
  ...
  buildTypes {
    release {
      ...
      minifyEnabled true
      // proguardFiles getDefaultProguardFile("proguard-android-optimize.txt"), "proguard-rules.pro"
      proguardFiles getDefaultProguardFile("proguard-android.txt"), "proguard-rules.pro"
    }
  }
}
```
Читайте документацию:
https://reactnative.dev/docs/signed-apk-android#enabling-proguard-to-reduce-the-size-of-the-apk-optional


# 4. .env
`.env` файл - это текстовый файл, который обычно используется для хранения конфигурационных переменных в проекте. Он представляет собой простой текстовый файл без форматирования, где каждая строка содержит пару "ключ=значение". Такие файлы обычно используются для хранения конфиденциальной информации, такой как секреты API, токены, адреса баз данных и другие настройки, которые не должны быть публично доступны в репозитории.

Вот пример простого `.env` файла:

```plaintext
API_KEY=your_api_key
DATABASE_URL=https://example.com/db
DEBUG=true
```

Здесь:

- `API_KEY` - это ключ API, который может использоваться в приложении.
- `DATABASE_URL` - это URL для подключения к базе данных.
- `DEBUG` - это флаг для включения или отключения режима отладки.

Когда проект загружается или выполняется, переменные из `.env` файла могут быть считаны и использованы в коде. Важно отметить, что `.env` файл обычно не должен быть включен в систему контроля версий (например, Git), чтобы избежать случайного раскрытия конфиденциальной информации. Вместо этого, в репозиторий следует добавить файл `.env.example` с примерами переменных, чтобы другие разработчики могли видеть, какие переменные им нужны, и создавать свои собственные `.env` файлы.


# 5. Cтавим одного и того же юзерагента и настраиваем firewall на сервере
Настройка одного и того же юзерагента (User-Agent) через интерцептор и настройка firewall на сервере - это части процесса управления запросами и безопасности в веб-разработке. Давайте разберем каждый из этих аспектов.

### 1. Установка одного и того же юзерагента через интерцептор:

Интерцепторы - это механизм во многих веб-фреймворках и библиотеках, который позволяет перехватывать и модифицировать HTTP-запросы и ответы. В контексте вопроса, мы говорим об установке одного и того же юзерагента для всех запросов.

Пример для Axios (JavaScript/Node.js):

```ts
import Axios from "axios";

   constructor() {
        Axios.interceptors.request.use(function (config) {
            config.headers['User-Agent'] = HTTP_USER_AGENT_STRING; //from env
            return config;
        });
    }
```

Это создаст экземпляр Axios с заранее установленными заголовками, включая 'User-Agent'.

### 2. Настройка firewall на сервере:

Firewall (брандмауэр) - это программное или аппаратное устройство, которое контролирует трафик между компьютером или сетью и интернетом. Он может быть настроен для блокировки или разрешения определенных типов трафика. Настраивая firewall, вы определяете, какие запросы разрешены, а какие блокированы.