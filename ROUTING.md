### Инструкция по именованию ресурсов и действий в RESTful веб-сервисах ###
---

# Конвенции именования #

В названии роута не должно быть ***глаголов***.

1) Название ресурса - это существительное во множественном числе.
Предположим, у вас есть простой интернет-магазин, в котором присутствуют 4 ресурса:
- Книги (books).
- Заказы (orders).
- Авторы (authors).
- Пользователи (users).
  
2) Действие над ресурсом - это HTTP-метод, указанный клиентом (потребителем нашего API).
- GET – получить ресурс.
- POST – создать ресурс.
- PUT – изменить ресурс полностью (обновить).
- DELETE – удалить ресурс.
- PATCH – частично изменить ресурс.

# Практика #

1) Получение всех книг из магазина:
``` 
GET /books
``` 

2) Получение книг на английском языке:
```
GET /books?language=english
``` 

3) Получение книги с пагинацией:
```
GET /books?limit=10&offset=10
```

4) Получение книги с идентификатором 100:
```
GET /books/100
```

5) Получение нескольких книг по их идентификаторам:
```
GET /books?ids=1,2,3
```

5) Получение информации о текущем пользователе:
```
GET /users/me
```

6) Получение заказов пользователя по его идентификатору:
```
GET /users/123/orders
<!-- GET /orders?userId=123 -->
```

7) Добавление новой книги:
```
POST /books
```

8) Обновление информации о книге:
```
PUT /books/100
```

9) Частичное обновление информации о книге:
```
PATCH /books/100
```

10)  Покупка книги:
```
POST /books/100/orders
```

11)  Получение заказов по книгам определенного автора:
```
GET /authors/2/books/100/orders
```

12)  Удаление книги:
```
DELETE /books/100
```

## Эффективное использование кодов ответов HTTP ##

- 200 OK — это ответ на успешные GET, PUT, PATCH или DELETE. Этот код также используется для POST, который не приводит к созданию.
- 201 Created — этот код состояния является ответом на POST, который приводит к созданию.
- 204 Нет содержимого. Это ответ на успешный запрос, который не будет возвращать тело (например, запрос DELETE)
- 304 Not Modified — используйте этот код состояния, когда заголовки HTTP-кеширования находятся в работе
- 400 Bad Request — этот код состояния указывает, что запрос искажен, например, если тело не может быть проанализировано
- 401 Unauthorized — Если не указаны или недействительны данные аутентификации. Также полезно активировать всплывающее окно auth, если приложение используется из браузера
- 403 Forbidden — когда аутентификация прошла успешно, но аутентифицированный пользователь не имеет доступа к ресурсу
- 404 Not found — если запрашивается несуществующий ресурс
- 405 Method Not Allowed — когда запрашивается HTTP-метод, который не разрешен для аутентифицированного пользователя
- 410 Gone — этот код состояния указывает, что ресурс в этой конечной точке больше не доступен. Полезно в качестве защитного ответа для старых версий API
- 415 Unsupported Media Type. Если в качестве части запроса был указан неправильный тип содержимого
- 422 Unprocessable Entity — используется для проверки ошибок
- 429 Too Many Requests — когда запрос отклоняется из-за ограничения скорости



Уявімо, що у вас є найпростіший інтернет-магазин, в якому є 4 ресурси:
Книги (books).
Замовлення (orders).
Автори (authors).
Користувачі (users).

У програмуванні ми вже використовуємо кілька конвенцій, пов’язаних з найменуванням:
Назва класiв — іменники.
Назва інтерфейсiв — іменники або прикметники.
Назва методiв (функцiй) — дієслова.
Назва змінних — іменники або прикметники.

В RESTful вебсервісах прийнята така конвенція:
Назва ресурсу — це іменник у множині
Дія над ресурсом — це HTTP-метод, який вказує клієнт (споживач нашого API).
GET — отримати ресурс.
POST — створити ресурс.
PUT — змінити ресурс повністю (оновити).
DELETE — видалити ресурс.
PATCH — частково змінити ресурс.

Практика
1. Отже, вам потрібно отримати всі книги з магазину. У такому випадку клієнт повинен відправити запит на сервер:
GET /books
1. Тепер вам потрібно отримати книги англійською мовою. Чи можемо ми вибрати для нового сервісу URI /englishbooks або /books/english?
В принципі ніхто нам це не може заборонити, але з часом виникнуть нові запити і нові endpoints /availablebooks, /soldoutbooks тощо. У цьому разі English, available, sold out — це атрибути стану ресурсу (книги), і ми в нашому сервісі хочемо фільтрувати книги з тих чи інших атрибутів.
У REST API прийнята така конвенція. Для сортування, фільтрації та обмеження ресурсів використовуйте параметри запиту (query parameters). Тоді наші URI будуть виглядати так:
/books?type=available або /books?language=english
Такий підхід допоможе нам одним REST API виконати будь-яку операцію з пошуку ресурсів, змінюючи тільки параметри запитів.
1. Тепер вам потрібно повернути книгу з ідентифікатором 100. У минулому прикладі ми використовували параметри запиту для фільтрації. Чи можемо ми використовувати їх і в цьому випадку?
У REST API прийнято використовувати символ «/» для відображення ієрархічної залежності між ресурсами. Тому нам варто вибрати альтернативний варіант — параметри шляху (path variables). І в такому варіанті URI буде /books /100. 
1. Ідентифікатори не завжди передаються як параметри шляху. У разі BATCH-запиту, коли ми хочемо отримати відразу кілька ресурсів за їх ідентифікаторами, ми вже використовуємо параметри запиту:
GET /books?ids=1,2,3
1. У нашому інтернет-магазині потрібен REST-сервіс для отримання інформації про поточного (залогіненого) клієнта. REST або HTTP ніяк не роз’яснюють цю ситуацію. За аналогією з попередніми прикладами ви можете використовувати URI:
GET /users/user_login
Такий варіант існує, наприклад, у BitBucket. Але є більш популярний підхід, який використовують GitHub, StackExchange, Facebook і багато інших. Вони ввели спеціальний ресурс — авторизований користувач, і URI виглядає відповідно: /me, /self або навіть /users/me або /users/current. Це не суперечить REST, оскільки ви самі вибираєте назву для ваших ресурсів. А ідентифікатор користувача передається в заголовку запиту Authorization (або якимось іншим способом). До того ж це приватний API, який ніколи буде використаний стороннім сервісом або клієнтом.
Іноді трапляється варіант /user, і він мені здається неправильним, тому що назва ресурсу повинна бути у множині. А /users теж не підходить, тому що GET /users повинен повернути всіх користувачів.
1. Тепер потрібно повернути замовлення користувача за його ідентифікатором. Якщо ви впевнені, що URI повинен бути /orders/REF9423402343, то тут потрібно згадати про те, що ресурси бувають трьох видів:
Незалежні — можуть існувати без прив’язки до інших ресурсів.
Залежні — існують тільки в контексті інших ресурсiв (як inner classes в Java).
Асоціативні — незалежні ресурси, на які можна посилатися з інших ресурсів.
Замовлення не можна створити само собою, для цього потрібні ресурси-контейнери (книга і користувач), тому це залежний ресурс. Для залежних ресурсів в URI прийнято вказувати всіх його «батьків». Якщо ми хочемо отримати всі замовлення по книзі з ідентифікатором 100, то URI буде не /orders?bookId=100, а /books/100/orders. Такий підхід зручний тим, що можна відразу отримати URI «батька» — /books/100. Іноді трапляється варіант виду /books/orders/100, але він неправильний.
Тут виникає цікаве питання. А який може бути максимальний рівень вкладеності такого посилання? Практично я не бачив більше трьох. Наприклад, якщо ми хочемо отримати замовлення за книгами певного автора, то URI буде виду /authors/2/books/100/orders.
1. Яким буде URI для додавання нової книги? Для створення ресурсу згідно з HTTP-специфікацією використовується HTTP-метод POST, і тоді запит буде мати такий вигляд:
POST /books
Іноді трапляються неправильні підходи:
PUT /books — PUT використовується тільки для зміни наявного ресурсу.
POST /create-book — дію зазначено в URI.
GET /create-book — неправильний HTTP-метод.
Як бути з операцією купівлі книги? Часом бувають неправильні варіанти типу POST /books/100/pay. Тут знову ж дію вказують в самому URI. Щоб вибрати правильний варіант, потрібно відповісти на питання. Купівля книжки — це операція з яким ресурсом? Зрозуміло, із замовленням (його створення). Тому правильний варіант буде:
POST /books/100/orders
1. Для зміни ресурсу згідно з HTTP-специфікацією використовують HTTP-метод PUT, причому ми обов’язково вказуємо ідентифікатор ресурсу (навіть якщо він є в тілі запиту):
PUT /books/100
Але бувають і більш складні приклади. Наприклад, у книги є прапорець activated — чи доступна вона для продажу. Відповідно нам потрібно мати сервіс(и) для установки і скидання цього прапорця. Тут можна використовувати і PUT, але тоді нам доведеться отримати книгу з сервера, змінити activated, пройти шлях серіалізації → відправки по мережі → десеріалізацію і потім зміну всього вмісту в базі. Це дуже неощадливий варіант.
Іноді є варіанти, які я б назвав workarounds:
POST /books/100/activate.
POST /books/100?changeStatus=activated.
POST /books/100?action=activate.
Це, по суті, милиці, тому що в HTTP-специфікації є спеціальний HTTP-метод — PATCH, який використовується для часткової зміни ресурсу. Є навіть специфікація JSON Patch (RFC 6902), яка вказує формат тіла запиту:
[
{ «op»: «replace», «path»: «/activated», «value»: true}
]
У параметрі op вказують операцію над тим полем, яке міститься в параметрі path. Це може бути додавання, видалення, зміна, копіювання, переміщення або тестування. А сам запит буде виглядати так:
PATCH /books/100
І все ж є проєкти, де люблять вибирати свій шлях самурая. Наприклад, в LinkedIn API для часткової зміни потрібно вказати в заголовку запиту X-Restli-Method значення PARTIAL_UPDATE, а сам запит буде виглядати як POST /books/100.

https://dou.ua/forums/topic/34550/
https://habr.com/ru/articles/45458/
https://foxminded.ua/ru/chto-takoe-rest-api/

https://www.restapitutorial.com/lessons/httpmethods.html
https://restcookbook.com/Basics/loggingin/
https://habr.com/ru/articles/351890/